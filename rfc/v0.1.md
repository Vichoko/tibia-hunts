# TibiaHunts — MVP Spec & Architecture

> Goal: a simple, open site where players can register their hunts (sessions), build a community dataset of hunting spots, and later query “what’s the best place to hunt for my level/profession/setup?”.

---

## 0) Guiding Principles

* **MVP first**: create, view, and search hunts; minimal auth (email magic link or social); frictionless submission (allow anonymous + later claim).
* **Open data**: spots (locations/spawns) are community-editable with a light review model.
* **Analyzer-friendly**: support pasting/exporting **Hunt Analyzer** output and parse key stats.
* **Extensible**: design schemas & APIs to add ranking/recommendations later.

---

## 1) Core Domain Concepts

* **User**: optional account to own characters and hunts. Anonymous submissions allowed (with rate limits & soft moderation).
* **Character**: Tibia character name, world, vocation (Knight, Paladin, Sorcerer, Druid), level, and optional attributes (elemental imbues, etc.). Optionally fetched from a fansite API (e.g., tibia-data) on-demand to verify existence.
* **Spot (Spawn/Location)**: a huntable place (e.g., “Vandura -4” / “Banuta -4”). Has name, city/area, coordinates/notes, recommended level ranges, typical roles.
* **Hunt**: a **session** at a spot on a date/time with **n** participants (characters + roles), duration, and **metrics** (XP/hr, loot/hr, supplies/hr, net profit/hr, kills, etc.). Optionally includes **AnalyzerUpload** for raw text and parsed fields.
* **Participant**: link between Hunt and Character with role (e.g., EK, RP, MS, ED), plus booleans (leader, booster, etc.).

---

## 2) Data Model (ERD)

```
Users (id, email, display_name, created_at)
Characters (id, user_id?, name, world, vocation, level, verified_at?)
Spots (id, name, area, city, floor, notes, min_level?, max_level?, coords?, created_by?)
Hunts (id, spot_id, started_at, duration_min, party_size, submitted_by?, analyzer_id?)
HuntParticipants (id, hunt_id, character_id, role, remark?)
HuntMetrics (id, hunt_id, xp_per_hour, loot_per_hour, supplies_per_hour, profit_per_hour, kills, deaths, charm_points?, prey?, stamina_start?, stamina_end?)
AnalyzerUploads (id, hunt_id?, raw_text, parsed_json, parser_version, uploaded_by)
Professions (code, name)  -- seed: EK, RP, MS, ED (and maybe KNIGHT, PALADIN, SORCERER, DRUID synonyms)

Indexes:
- Characters(name, world) unique
- Spots(name, area, floor) unique-ish (soft uniqueness + moderation)
- Hunts(spot_id, started_at)
- HuntMetrics(profit_per_hour, xp_per_hour)
- Full-text on Spots(name, area, city, notes)
```

### Notes

* Keep **Routes** out of MVP; store in `notes` and add a `Routes` table later.
* `AnalyzerUploads.parsed_json` stores structured values even if raw text is not perfectly stable across client versions.

---

## 3) Minimal Feature Set (MVP)

1. **Submit Hunt**

   * Choose/create **Spot** (autocomplete, create-if-not-exists with low-friction form).
   * Set **date/time**, **duration**, **party size**.
   * Add **participants** (free-text names + vocation dropdown; attach to existing/auto-create Characters).
   * Paste **Hunt Analyzer** export (optional). Parser extracts XP/hr, Loot/hr, Supplies/hr, Profit/hr, kills, etc.
   * Save.

2. **Browse & Search**

   * Spot directory (name, recommended level range, recent avg XP/hr & Profit/hr from community data).
   * Hunt feed with filters: vocation composition (solo knight, duo EK+ED, 4vocation), level range, world, date range.

3. **Character pages**

   * Show recent hunts, average metrics, usual spots.

4. **Authentication (light)**

   * Email magic link (or Google) via a BaaS (e.g., Supabase Auth). Anonymous allowed.

5. **Moderation**

   * Simple flag/report per Spot/Hunt; maintain edit history for Spots.

---

## 4) Non-Goals (MVP)

* Real-time party coordination, route maps, loot distribution automation, or full editorial workflows.
* Hard validations against in-game logs beyond Analyzer paste.

---

## 5) Tech Stack (proposed)

* **Frontend**: Next.js (App Router), TypeScript, Tailwind, shadcn/ui.
* **Backend**: Next.js API routes or **FastAPI** behind an API gateway. For speed, Next.js server actions + **Supabase** works well.
* **DB**: Postgres (Supabase) with row-level security (RLS). PG full-text for spots; later add **pgvector** for semantic search.
* **Parsing**: server-side parser (Python or TS). Versioned (`parser_version`) to handle client drift.
* **Background jobs**: Supabase Edge Functions / Vercel Cron for daily recomputes (spot aggregates).

---

## 6) External Integrations

* **Tibia character lookup**: optional on-demand fetch to confirm character existence and world; cache result on `Characters`.
* **(Later)** World events/boosted creatures.

---

## 7) API Design (MVP)

### REST (v1)

* `POST /api/v1/hunts` — create Hunt (+ participants, metrics, analyzer raw)
* `GET  /api/v1/hunts` — list/filter hunts (`vocation=EK,party=solo|miniduos|full`, `level_min/max`, `world`, `spot_id`, `date_from/to`)
* `GET  /api/v1/hunts/{id}` — detail
* `POST /api/v1/spots` — create spot
* `GET  /api/v1/spots` — search/browse (`q`, `level_min/max`)
* `GET  /api/v1/spots/{id}` — detail with aggregates
* `POST /api/v1/characters` — create/claim character
* `GET  /api/v1/characters/{name}` — show character (by name+world)

### Aggregates (server-computed & cached)

* Spot KPIs: `avg_xp_per_hour`, `avg_profit_per_hour`, `sample_size`, `last_30d` vs `lifetime`.
* Composition buckets: solo, duo, trio, full (by vocations).

---

## 8) Analyzer Parsing (MVP)

* **Input**: raw text pasted by user from Tibia Hunt Analyzer (client-dependent). Support multiple locales; detect with regex.

* **Strategy**: regex & line-by-line fallbacks; tolerate missing fields.

* **Parsed fields** (examples):

  * `duration_min`
  * `xp_total`, `xp_per_hour`
  * `loot_total`, `loot_per_hour`
  * `supplies_total`, `supplies_per_hour`
  * `balance_total`, `profit_per_hour`
  * `kills`, `deaths`
  * `stamina_start`, `stamina_end` (if present)
  * `boosts`: prey/hunt blessing/praise (if detectable)

* **Validation**: warn if `party_size` ≠ #participants; require at least one metric present.

---

## 9) Ranking & Recommendation (Phase 2)

* **Query**: “I’m a {vocation}, level {L}, party = {solo/duo/full}, world = {opt}, goal = {xp|profit}. What spots?”
* **Heuristics v1**: filter spots with enough samples near level L; compute score = w1·zscore(xp/hr) + w2·recency\_bonus + w3·sample\_penalty.
* **ML v2**: train a two-tower (user(setup)->spot) or gradient-boosted model on hunt outcomes; include features: level, party comp, world, spot id, date, boosts.
* **Semantic search**: pgvector embeddings over spot notes and user queries.

---

## 10) UX Flows

1. **Quick Submit** (no account)

   * Select/Create Spot → Paste Analyzer → Add participants (names + vocation) → Save → (optional) leave email to claim later.

2. **Claim Character**

   * Sign in → Add your character(s) by name+world → we auto-link hunts where you participated.

3. **Browse Spots**

   * Cards with avg XP/hr & Profit/hr, sample size, common comps, last seen date.

---

## 11) Security & Abuse

* Rate-limit anonymous posts.
* RLS: users can edit their hunts; spots are community-editable with version history; admins can revert.
* Basic spam filters on Analyzer text size and frequency.

---

## 12) Schema (DDL sketch for Postgres)

```sql
create table users (
  id uuid primary key default gen_random_uuid(),
  email text unique,
  display_name text,
  created_at timestamptz default now()
);

create table professions (
  code text primary key, -- EK, RP, MS, ED
  name text not null
);

create table characters (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references users(id),
  name text not null,
  world text not null,
  vocation text references professions(code),
  level int,
  verified_at timestamptz,
  unique(name, world)
);

create table spots (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  area text,
  city text,
  floor int,
  notes text,
  min_level int,
  max_level int,
  coords jsonb,
  created_by uuid references users(id)
);

create table hunts (
  id uuid primary key default gen_random_uuid(),
  spot_id uuid references spots(id) not null,
  started_at timestamptz not null,
  duration_min int,
  party_size int,
  submitted_by uuid references users(id),
  analyzer_id uuid
);

create table hunt_participants (
  id uuid primary key default gen_random_uuid(),
  hunt_id uuid references hunts(id) on delete cascade,
  character_id uuid references characters(id),
  role text references professions(code),
  remark text
);

create table hunt_metrics (
  id uuid primary key default gen_random_uuid(),
  hunt_id uuid references hunts(id) on delete cascade,
  xp_per_hour int,
  loot_per_hour int,
  supplies_per_hour int,
  profit_per_hour int,
  kills int,
  deaths int,
  charm_points int,
  prey jsonb,
  stamina_start int,
  stamina_end int
);

create table analyzer_uploads (
  id uuid primary key default gen_random_uuid(),
  hunt_id uuid references hunts(id) on delete set null,
  raw_text text not null,
  parsed_json jsonb,
  parser_version text not null,
  uploaded_by uuid references users(id),
  created_at timestamptz default now()
);

create index on spots using gin (to_tsvector('simple', coalesce(name,'') || ' ' || coalesce(area,'') || ' ' || coalesce(city,'') || ' ' || coalesce(notes,'')));
create index on hunt_metrics (profit_per_hour desc, xp_per_hour desc);
```

---

## 13) API Contracts (examples)

### Create Hunt

```http
POST /api/v1/hunts
Content-Type: application/json
{
  "spot": {"id": "..."} | {"name": "Banuta -4", "area": "Port Hope", "floor": -4, "notes": "south loop"},
  "started_at": "2025-08-26T21:00:00Z",
  "duration_min": 120,
  "participants": [
    {"name": "Vykter", "world": "Inabra", "role": "EK", "level": 350},
    {"name": "Healer", "world": "Inabra", "role": "ED", "level": 330}
  ],
  "analyzer_raw": "...pasted text...",
  "metrics": {"xp_per_hour": 6200000, "loot_per_hour": 1_800_000, "supplies_per_hour": 900_000, "profit_per_hour": 900_000}
}
```

**Response** `201 Created`

```json
{"id":"<hunt_id>","spot_id":"<spot_id>"}
```

### List Spots

```http
GET /api/v1/spots?q=banuta&level_min=250&level_max=400
```

---

## 14) Parsing Plan (regex sketch)

* Detect locale lines: `/XP Gain:|Experiencia:/`, `/Loot:/`, `/Supplies:/`, `/Balance:/`.
* Extract numbers with `([\d.,]+)` then normalize (commas vs dots).
* Duration: parse `H:MM` patterns or lines like `Session: 2h 15m`.
* Fallback: compute per-hour from totals if duration present.
* Store both `raw_text` and `parsed_json`.

---

## 15) Aggregations & Spot Scores

* Nightly job to compute for each Spot and party comp:

  * `avg_xp_per_hour`, `avg_profit_per_hour`, `n_samples`, `last_seen_at`.
* **Score v1**: `z_xp * 0.6 + z_profit * 0.4 + recency_bonus - small_sample_penalty`.

---

## 16) Roadmap

**M1 (week 1–2)**

* Repo scaffold, DB schema in Supabase, seed professions.
* Public pages: Home, Spots list/detail, Create Hunt.
* Anonymous submission + magic link auth.
* Analyzer parser v0 + minimal stats display.

**M2 (week 3–4)**

* Character pages + claim flow.
* Spot aggregates + leaderboards by vocation & party comp.
* Simple moderation & edit history for Spots.

**M3 (week 5–6)**

* Natural-language query (rules-based).
* pgvector for semantic search on spot notes.
* Export public dataset (CSV/JSON).

---

## 17) Open Questions

* Standardize spot naming (Banuta vs Vandura typo) — add alias table later.
* Handle server/world-specific meta? (prices affect profit/hr)
* Optional currency normalization (gp vs estimated CLP/USD? likely gp only in MVP).
* Party cap at 4? (keep flexible, but UI pre-sets common comps).

---

## 18) Nice-to-haves (post-MVP)

* Route diagrams per spot; multiple routes per spot with crowd-sourced safety/tips.
* Boosted creature/calendar awareness.
* OAuth with fansite to verify characters.
* “Session recorder” bookmarklet to timestamp changes (advanced).

---

## 19) Success Criteria (MVP)

* ≥100 hunts submitted by ≥30 unique players in first month.
* ≥50 spots with ≥3 hunts each.
* NL query returns sensible top-5 spots for 4 common profiles.

---

## 20) Tracking & Analytics

* Basic pageview + conversion events (submit start, submit success).
* Opt-in telemetry only; no third-party cookies.

---

## 21) Branding/UX Sketch

* Clean, game-adjacent palette; simple cards.
* Submission form is 1 page, progressive disclosure for advanced fields.

---

*End of spec v0.1*
